import _ from "bsv/util/_.js";
import assert from "assert";
const should = require("chai").should();
import { expect } from "chai";
import bsv from "bsv";
const errors = bsv.errors;
const hdErrors = errors.HDPrivateKey;
import buffer from "buffer";
const Networks = bsv.Networks;
import JSUtil from "bsv/util/js.js";
const HDPrivateKey = bsv.HDPrivateKey;
const Base58Check = bsv.encoding.Base58Check;

const xprivkey =
  "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi";
const json =
  '{"network":"livenet","depth":0,"fingerPrint":876747070,"parentFingerPrint":0,"childIndex":0,"chainCode":"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508","privateKey":"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35","checksum":3883834737,"xprivkey":"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi"}';
describe("HDPrivate key interface", () => {
  const expectFail = (func, error) => {
    let got = null;
    try {
      func();
    } catch (e) {
      got = e instanceof error;
    }
    expect(got).to.equal(true);
  };

  const expectDerivationFail = (argument, error) =>
    expectFail(() => {
      const privateKey = new HDPrivateKey(xprivkey);
      privateKey.deriveChild(argument);
    }, error);

  const expectFailBuilding = (argument, error) =>
    expectFail(() => new HDPrivateKey(argument), error);

  const expectSeedFail = (argument, error) =>
    expectFail(() => HDPrivateKey.fromSeed(argument), error);

  it("should make a new private key from random", () => {
    should.exist(new HDPrivateKey().xprivkey);
  });

  it("should make a new private key from random for testnet", () => {
    const key = new HDPrivateKey("testnet");
    should.exist(key.xprivkey);
    key.network.name.should.equal("testnet");
  });

  it("should not be able to change read-only properties", () => {
    const hdkey = new HDPrivateKey();
    expect(() => {
      hdkey.fingerPrint = "notafingerprint";
    }).to.throw(TypeError);
  });

  it("should error with an invalid checksum", () => {
    expectFailBuilding(`${xprivkey}1`, errors.InvalidB58Checksum);
  });

  it("can be rebuilt from a json generated by itself", () => {
    const regenerate = new HDPrivateKey(json);
    regenerate.xprivkey.should.equal(xprivkey);
  });

  it("builds a json keeping the structure and same members", () => {
    assert.deepStrictEqual(
      new HDPrivateKey(json).toJSON(),
      new HDPrivateKey(xprivkey).toJSON(),
    );
  });

  describe("instantiation", () => {
    it("invalid argument: can not instantiate from a number", () => {
      expectFailBuilding(1, hdErrors.UnrecognizedArgument);
    });
    it("allows no-new calling", () => {
      HDPrivateKey(xprivkey).toString().should.equal(xprivkey);
    });
    it("allows the use of a copy constructor", () => {
      HDPrivateKey(HDPrivateKey(xprivkey))
        .xprivkey.should.equal(xprivkey);
    });
  });

  describe("public key", () => {
    const testnetKey = new HDPrivateKey(
      "tprv8ZgxMBicQKsPdEeU2KiGFnUgRGriMnQxrwrg6FWCBg4jeiidHRyCCdA357kfkZiGaXEapWZsGDKikeeEbvgXo3UmEdbEKNdQH9VXESmGuUK",
    );
    const livenetKey = new HDPrivateKey(
      "xprv9s21ZrQH143K3e39bnn1vyS7YFa1EAJAFGDoeHaSBsgBxgAkTEXeSx7xLvhNQNJxJwhzziWcK3znUFKRPRwWBPkKZ8ijUBa5YYpYPQmeBDX",
    );

    it("matches the network", () => {
      testnetKey.publicKey.network.should.equal(Networks.testnet);
      livenetKey.publicKey.network.should.equal(Networks.livenet);
    });

    it("cache for xpubkey works", () => {
      const privateKey = new HDPrivateKey(xprivkey);
      should.not.exist(privateKey._hdPublicKey);
      privateKey.xpubkey.should.equal(privateKey.xpubkey);
      should.exist(privateKey._hdPublicKey);
    });
  });

  it("inspect() displays correctly", () => {
    HDPrivateKey(xprivkey).inspect().should.equal(
      `<HDPrivateKey: ${xprivkey}>`,
    );
  });
  it("fails when trying to derive with an invalid argument", () => {
    expectDerivationFail([], hdErrors.InvalidDerivationArgument);
  });

  it("catches early invalid paths", () => {
    expectDerivationFail("s", hdErrors.InvalidPath);
  });

  it("allows derivation of hardened keys by passing a very big number", () => {
    const privateKey = new HDPrivateKey(xprivkey);
    const derivedByNumber = privateKey.deriveChild(0x80000000);
    const derivedByArgument = privateKey.deriveChild(0, true);
    derivedByNumber.xprivkey.should.equal(derivedByArgument.xprivkey);
  });

  it("returns itself with 'm' parameter", () => {
    const privateKey = new HDPrivateKey(xprivkey);
    privateKey.should.equal(privateKey.deriveChild("m"));
  });

  it("returns InvalidArgument if invalid data is given to getSerializedError", () => {
    expect(
      HDPrivateKey.getSerializedError(1) instanceof
        hdErrors.UnrecognizedArgument,
    ).to.equal(true);
  });

  it("returns InvalidLength if data of invalid length is given to getSerializedError", () => {
    const b58s = Base58Check.encode(buffer.Buffer.from("onestring"));
    expect(
      HDPrivateKey.getSerializedError(b58s) instanceof hdErrors.InvalidLength,
    ).to.equal(true);
  });

  it("returns InvalidNetworkArgument if an invalid network is provided", () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, "invalidNetwork") instanceof
        errors.InvalidNetworkArgument,
    ).to.equal(true);
  });

  it("recognizes that the wrong network was asked for", () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, "testnet") instanceof
        errors.InvalidNetwork,
    ).to.equal(true);
  });

  it("recognizes the correct network", () => {
    expect(HDPrivateKey.getSerializedError(xprivkey, "livenet")).to.equal(null);
  });

  describe("on creation from seed", () => {
    it("converts correctly from an hexa string", () => {
      should.exist(
        HDPrivateKey.fromSeed("01234567890abcdef01234567890abcdef").xprivkey,
      );
    });
    it("fails when argument is not a buffer or string", () => {
      expectSeedFail(1, hdErrors.InvalidEntropyArgument);
    });
    it("fails when argument doesn't provide enough entropy", () => {
      expectSeedFail("01", hdErrors.InvalidEntropyArgument.NotEnoughEntropy);
    });
    it("fails when argument provides too much entropy", () => {
      let entropy = "0";
      for (let i = 0; i < 129; i++) {
        entropy += "1";
      }
      expectSeedFail(entropy, hdErrors.InvalidEntropyArgument.TooMuchEntropy);
    });
  });

  it("correctly errors if an invalid checksum is provided", () => {
    const privKey = new HDPrivateKey(xprivkey);
    let error = null;
    try {
      const buffers = privKey._buffers;
      buffers.checksum = JSUtil.integerAsBuffer(0);
      new HDPrivateKey(buffers); //eslint-disable-line
    } catch (e) {
      error = e;
    }
    expect(error instanceof errors.InvalidB58Checksum).to.equal(true);
  });
  it("correctly validates the checksum", () => {
    const privKey = new HDPrivateKey(xprivkey);
    expect(() => {
      const buffers = privKey._buffers;
      return new HDPrivateKey(buffers);
    }).to.not.throw();
  });

  it("shouldn't matter if derivations are made with strings or numbers", () => {
    const privateKey = new HDPrivateKey(xprivkey);
    const derivedByString = privateKey.deriveChild("m/0'/1/2'");
    const derivedByNumber = privateKey.deriveChild(0, true).deriveChild(1)
      .deriveChild(2, true);
    derivedByNumber.xprivkey.should.equal(derivedByString.xprivkey);
  });

  describe("validates paths", () => {
    it("validates correct paths", () => {
      let valid;

      valid = HDPrivateKey.isValidPath("m/0'/1/2'");
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath("m");
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(123, true);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(123);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123);
      valid.should.equal(true);

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123, true);
      valid.should.equal(true);
    });

    const invalid = [
      "m/-1/12",
      "bad path",
      "K",
      "m/",
      "m/12asd",
      "m/1/2//3",
    ];

    invalid.forEach((datum) => {
      it(`rejects illegal path ${datum}`, () => {
        HDPrivateKey.isValidPath(datum).should.equal(false);
        expect(HDPrivateKey._getDerivationIndexes(datum)).to.equal(null);
      });
    });

    it("generates deriving indexes correctly", () => {
      let indexes;

      indexes = HDPrivateKey._getDerivationIndexes("m/-1/12");
      expect(indexes).to.equal(null);

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'");
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12]);

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'");
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12]);
    });
  });

  describe("conversion to/from buffer", () => {
    const str =
      "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi";
    it("should roundtrip to/from a buffer", () => {
      const priv = new HDPrivateKey(str);
      const toBuffer = priv.toBuffer();
      const fromBuffer = HDPrivateKey.fromBuffer(toBuffer);
      const roundTrip = new HDPrivateKey(fromBuffer.toString());
      roundTrip.xprivkey.should.equal(str);
    });
  });

  describe("conversion to/from hex", () => {
    const str =
      "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi";
    it("should roundtrip to/from a buffer", () => {
      const priv = new HDPrivateKey(str);
      const toBuffer = priv.toBuffer();
      const fromBuffer = HDPrivateKey.fromBuffer(toBuffer);
      const roundTrip = new HDPrivateKey(fromBuffer.toString());
      roundTrip.xprivkey.should.equal(str);
    });
  });

  describe("from random", () => {
    const str =
      "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi";
    it("should roundtrip to/from a buffer", () => {
      const xprv1 = new HDPrivateKey(str);
      const xprv2 = HDPrivateKey.fromRandom();
      const xprv3 = HDPrivateKey.fromRandom();
      xprv1.toString().should.not.equal(xprv2.toString());
      xprv2.toString().should.not.equal(xprv3.toString());
      xprv1.toString().should.not.equal(xprv3.toString());
    });
  });

  describe("conversion to plain object/json", () => {
    const plainObject = {
      "network": "livenet",
      "depth": 0,
      "fingerPrint": 876747070,
      "parentFingerPrint": 0,
      "childIndex": 0,
      "chainCode":
        "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508",
      "privateKey":
        "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35",
      "checksum": 3883834737,
      "xprivkey":
        "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvN" +
        "KmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi",
    };
    it("toObject leaves no Buffer instances", () => {
      const privKey = new HDPrivateKey(xprivkey);
      const object = privKey.toObject();
      _.each(_.values(object), (value) => {
        expect(Buffer.isBuffer(value)).to.equal(false);
      });
    });
    it("roundtrips toObject", () => {
      expect(
        HDPrivateKey.fromObject(new HDPrivateKey(xprivkey).toObject()).xprivkey,
      ).to.equal(xprivkey);
    });
    it("roundtrips to JSON and to Object", () => {
      const privkey = new HDPrivateKey(xprivkey);
      expect(HDPrivateKey.fromObject(privkey.toJSON()).xprivkey).to.equal(
        xprivkey,
      );
    });
    it("recovers state from JSON", () => {
      new HDPrivateKey(JSON.stringify(plainObject)).xprivkey.should.equal(
        xprivkey,
      );
    });
    it("recovers state from Object", () => {
      new HDPrivateKey(plainObject).xprivkey.should.equal(xprivkey);
    });
  });
});
